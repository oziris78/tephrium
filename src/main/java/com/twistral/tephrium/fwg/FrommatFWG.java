// Copyright 2024 Oğuzhan Topaloğlu
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


package com.twistral.tephrium.fwg;


import com.twistral.tephrium.core.TephriumException;
import com.twistral.tephrium.prng.SplitMix64Random;
import com.twistral.tephrium.prng.TRandomGenerator;


import java.util.*;
import static com.twistral.tephrium.strings.TStringUtils.*;



/**
 * FrommatFWG (FROM forMAT Fake Word Generator) allows users to generate random words with a specific format. <br>
 * It parses and caches all the formats given to it and generates words using those formats. <br>
 * It has its own formatting language that is explained in the {@link #getRandomString(String, String...)} method. <br>
 *
 * Here are few words that were generated by the {@code "T[vl][cl][vl]![[#x][#x]!]"} format
 * string: Tulu[69], Tare[B7], Tade[14], Tina[7F].
 */
public class FrommatFWG {

    private final TRandomGenerator random;
    private final HashMap<String, List<String>> cachedFormats; // { formatStr : alphabetForRandChar }

    public static final int INITIAL_CACHE_CAP = 128;

    public FrommatFWG(TRandomGenerator random, int initialCacheCapacity) {
        this.random = random;
        this.cachedFormats = new HashMap<>(initialCacheCapacity);
    }

    public FrommatFWG() {
        this(new SplitMix64Random(), INITIAL_CACHE_CAP);
    }


    /////////////////////////////////////////////////////////////////////
    /////////////////////////////  METHODS  /////////////////////////////
    /////////////////////////////////////////////////////////////////////


    /**
     * Generates a random string that corresponds with the given format string. <br><br>
     *
     * The format string must follow the following syntax: <br>
     * - <b>[al]</b>  =>   any lowercase ascii letter <br>
     * - <b>[au]</b>  =>   any uppercase ascii letter <br>
     * - <b>[aa]</b>  =>   any ascii letter (including both lowercase and uppercase) <br>
     * - <b>[vl]</b>  =>   any lowercase vowel <br>
     * - <b>[vu]</b>  =>   any uppercase vowel <br>
     * - <b>[va]</b>  =>   any vowel (including both lowercase and uppercase) <br>
     * - <b>[cl]</b>  =>   any lowercase consonant <br>
     * - <b>[cu]</b>  =>   any uppercase consonant <br>
     * - <b>[ca]</b>  =>   any consonant (including both lowercase and uppercase) <br>
     * - <b>[wh]</b>  =>   any whitespace character from the ASCII table <br>
     * - <b>[#b]</b>  =>   any binary number (from "01") <br>
     * - <b>[#o]</b>  =>   any octal number (from "01234567") <br>
     * - <b>[#d]</b>  =>   any decimal number (from "0123...89") <br>
     * - <b>[#x]</b>  =>   any hexadecimal number (from "0123...CDEF") <br>
     * - <b>[@i]</b>  =>   any letter from the i'th custom alphabet that was given to this function,
     *                     keep in mind that this number is 0-based. <br>
     * - <b>!</b>     =>   the special ignore symbol that can be used to escape these
     *                     characters: '!', '[', ']' <br><br>
     *
     * Here are some examples: <br>
     * - getRandomString("T[al][au]")                   => "ThA", "TuX", ...                    <br>
     * - getRandomString("C[vl][cl][vl]")               => "Cuxa", "Coke", ...                  <br>
     * - getRandomString("[#b][#b][#b][#b]")            => "1100", "0101", ...                  <br>
     * - getRandomString("[#d][#d][#d][#d]")            => "6704", "4811", ...                  <br>
     * - getRandomString("[#x][#x][#x][#x]")            => "A6B5", "F15E", ...                  <br>
     * - getRandomString("![Hi!] Worl[cl]!!")           => "[Hi] Worlx!", "[Hi] World!", ...    <br>
     * - getRandomString("[aa][@1][@0]", "ABC", "XYZ")  => "UXA", "kZA", ...                    <br><br>
     *
     * @param format the format string
     * @param customAlphabets any number of custom alphabets that can be referenced
     *     in the format string by the {@code @} symbol
     * @return a random string that corresponds with the given format
     */
    public String getRandomString(String format, String... customAlphabets) {
        List<String> steps = parseOrGetFromCache(format, customAlphabets);
        int length = steps.size();
        char[] result = new char[length];
        for (int i = 0; i < length; i++)
            result[i] = getRandCharFrom(steps.get(i), random);
        return new String(result);
    }


    //////////////////////////////////////////////////////////////////////////////
    /////////////////////////////  HELPER FUNCTIONS  /////////////////////////////
    //////////////////////////////////////////////////////////////////////////////


    private List<String> parseOrGetFromCache(String format, String... customAlphabets) {
        if(cachedFormats.containsKey(format)) {
            return cachedFormats.get(format);
        }

        List<String> steps = new LinkedList<>();
        final int formatLen = format.length();
        int i = 0;
        StringBuilder parenText = new StringBuilder();
        boolean inParen = false;

        while(i < formatLen) {
            char c = format.charAt(i);

            switch (c) {
                case '[': {
                    if(inParen) panic("you forgot to close a parenthesis");
                    inParen = true;
                    i++;
                } break;
                case ']': {
                    if(!inParen) panic("you forgot to open a parenthesis");

                    final String pc = parenText.toString();
                    parenText.setLength(0);

                    if(pc.equals("al")) steps.add(CS_ASCII_LOWER);
                    else if(pc.equals("au")) steps.add(CS_ASCII_UPPER);
                    else if(pc.equals("aa")) steps.add(CS_ASCII_ALL);
                    else if(pc.equals("vl")) steps.add(CS_VOWELS_LOWER);
                    else if(pc.equals("vu")) steps.add(CS_VOWELS_UPPER);
                    else if(pc.equals("va")) steps.add(CS_VOWELS_ALL);
                    else if(pc.equals("cl")) steps.add(CS_CONSONANTS_LOWER);
                    else if(pc.equals("cu")) steps.add(CS_CONSONANTS_UPPER);
                    else if(pc.equals("ca")) steps.add(CS_CONSONANTS_ALL);
                    else if(pc.equals("#b")) steps.add(CS_BINARY);
                    else if(pc.equals("#o")) steps.add(CS_OCTAL);
                    else if(pc.equals("#d")) steps.add(CS_DECIMAL);
                    else if(pc.equals("#x")) steps.add(CS_HEXADECIMAL);
                    else if(pc.equals("wh")) steps.add(CS_WHITESPACE);
                    else if(pc.startsWith("@")) {
                        try {
                            int alphabetIndex = Integer.parseInt(pc.substring(1));
                            if(!(alphabetIndex < customAlphabets.length))
                                panic("not enough alphabets were provided");

                            steps.add(customAlphabets[alphabetIndex]);
                        }
                        catch (Exception e) {
                            panic("invalid alphabet index after @: " + pc.substring(1));
                        }
                    }
                    else panic("invalid parenthesis content: " + pc);

                    inParen = false;
                    i++;
                } break;
                case '!': {
                    if(i + 1 == formatLen) panic("format string cant end with !");

                    steps.add(String.valueOf(format.charAt(i + 1)));
                    i += 2;
                } break;
                default: {
                    if(inParen) parenText.append(c);
                    else steps.add(String.valueOf(c));
                    i++;
                } break;
            }
        }

        cachedFormats.put(format, steps);
        return steps;
    }


    private static void panic(String s, Object... args) {
        throw new TephriumException("INVALID FORMAT: " + s, args);
    }


}
